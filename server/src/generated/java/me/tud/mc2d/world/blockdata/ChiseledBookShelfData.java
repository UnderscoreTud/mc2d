package me.tud.mc2d.world.blockdata;

import com.google.common.base.Preconditions;
import java.util.Locale;
import java.util.Map;
import javax.annotation.processing.Generated;
import me.tud.mc2d.world.block.BlockFace;
import me.tud.mc2d.world.blockdata.properties.HasFacing;
import org.jetbrains.annotations.ApiStatus;

/**
 * This class contains autogenerated code. Please do <b>NOT</b> edit manually.
 */
@Generated("me.tud.mc2d.generators.blocks.BlocksGenerator")
public final class ChiseledBookShelfData extends BlockData implements HasFacing {
    private static final long FACING_ALLOWED_MASK = (1L << BlockFace.NORTH.ordinal())
            | (1L << BlockFace.SOUTH.ordinal())
            | (1L << BlockFace.WEST.ordinal())
            | (1L << BlockFace.EAST.ordinal());

    private static final int FACING_RADIX = 4;

    private static final int SLOT0OCCUPIED_RADIX = 2;

    private static final int SLOT1OCCUPIED_RADIX = 2;

    private static final int SLOT2OCCUPIED_RADIX = 2;

    private static final int SLOT3OCCUPIED_RADIX = 2;

    private static final int SLOT4OCCUPIED_RADIX = 2;

    private static final int SLOT5OCCUPIED_RADIX = 2;

    static final int MAX_OFFSET = FACING_RADIX * SLOT0OCCUPIED_RADIX * SLOT1OCCUPIED_RADIX * SLOT2OCCUPIED_RADIX * SLOT3OCCUPIED_RADIX * SLOT4OCCUPIED_RADIX * SLOT5OCCUPIED_RADIX - 1;

    private @BlockFace.Values({BlockFace.NORTH, BlockFace.SOUTH, BlockFace.WEST, BlockFace.EAST}) BlockFace facing = BlockFace.NORTH;

    private boolean slot0Occupied = false;

    private boolean slot1Occupied = false;

    private boolean slot2Occupied = false;

    private boolean slot3Occupied = false;

    private boolean slot4Occupied = false;

    private boolean slot5Occupied = false;

    @ApiStatus.Internal
    public ChiseledBookShelfData(int startingID) {
        super(startingID);
    }

    @Override
    public @BlockFace.Values({BlockFace.NORTH, BlockFace.SOUTH, BlockFace.WEST, BlockFace.EAST}) BlockFace facing(
            ) {
        return this.facing;
    }

    @Override
    public void facing(
            @BlockFace.Values({BlockFace.NORTH, BlockFace.SOUTH, BlockFace.WEST, BlockFace.EAST}) BlockFace facing) {
        Preconditions.checkNotNull(facing, "facing");
        Preconditions.checkArgument((FACING_ALLOWED_MASK & (1L << facing.ordinal())) != 0L, "Invalid facing: " + facing);
        this.facing = facing;
    }

    private int facingToIndex() {
        return switch (this.facing) {
            case NORTH -> 0;
            case SOUTH -> 1;
            case WEST -> 2;
            case EAST -> 3;
            default -> throw new IllegalArgumentException("Invalid facing: " + facing);
        };
    }

    private void facingFromIndex(int index) {
        this.facing(switch (index) {
            case 0 -> BlockFace.NORTH;
            case 1 -> BlockFace.SOUTH;
            case 2 -> BlockFace.WEST;
            case 3 -> BlockFace.EAST;
            default -> throw new IllegalArgumentException("Index must be between [0, 3], got " + index);
        });
    }

    private void facingFromString(String value) {
        this.facing(BlockFace.parse(value));
    }

    public boolean slot0Occupied() {
        return this.slot0Occupied;
    }

    public void slot0Occupied(boolean slot0Occupied) {
        this.slot0Occupied = slot0Occupied;
    }

    private int slot0OccupiedToIndex() {
        return this.slot0Occupied ? 0 : 1;
    }

    private void slot0OccupiedFromIndex(int index) {
        this.slot0Occupied(index == 0);
    }

    private void slot0OccupiedFromString(String value) {
        this.slot0Occupied(Boolean.parseBoolean(value));
    }

    public boolean slot1Occupied() {
        return this.slot1Occupied;
    }

    public void slot1Occupied(boolean slot1Occupied) {
        this.slot1Occupied = slot1Occupied;
    }

    private int slot1OccupiedToIndex() {
        return this.slot1Occupied ? 0 : 1;
    }

    private void slot1OccupiedFromIndex(int index) {
        this.slot1Occupied(index == 0);
    }

    private void slot1OccupiedFromString(String value) {
        this.slot1Occupied(Boolean.parseBoolean(value));
    }

    public boolean slot2Occupied() {
        return this.slot2Occupied;
    }

    public void slot2Occupied(boolean slot2Occupied) {
        this.slot2Occupied = slot2Occupied;
    }

    private int slot2OccupiedToIndex() {
        return this.slot2Occupied ? 0 : 1;
    }

    private void slot2OccupiedFromIndex(int index) {
        this.slot2Occupied(index == 0);
    }

    private void slot2OccupiedFromString(String value) {
        this.slot2Occupied(Boolean.parseBoolean(value));
    }

    public boolean slot3Occupied() {
        return this.slot3Occupied;
    }

    public void slot3Occupied(boolean slot3Occupied) {
        this.slot3Occupied = slot3Occupied;
    }

    private int slot3OccupiedToIndex() {
        return this.slot3Occupied ? 0 : 1;
    }

    private void slot3OccupiedFromIndex(int index) {
        this.slot3Occupied(index == 0);
    }

    private void slot3OccupiedFromString(String value) {
        this.slot3Occupied(Boolean.parseBoolean(value));
    }

    public boolean slot4Occupied() {
        return this.slot4Occupied;
    }

    public void slot4Occupied(boolean slot4Occupied) {
        this.slot4Occupied = slot4Occupied;
    }

    private int slot4OccupiedToIndex() {
        return this.slot4Occupied ? 0 : 1;
    }

    private void slot4OccupiedFromIndex(int index) {
        this.slot4Occupied(index == 0);
    }

    private void slot4OccupiedFromString(String value) {
        this.slot4Occupied(Boolean.parseBoolean(value));
    }

    public boolean slot5Occupied() {
        return this.slot5Occupied;
    }

    public void slot5Occupied(boolean slot5Occupied) {
        this.slot5Occupied = slot5Occupied;
    }

    private int slot5OccupiedToIndex() {
        return this.slot5Occupied ? 0 : 1;
    }

    private void slot5OccupiedFromIndex(int index) {
        this.slot5Occupied(index == 0);
    }

    private void slot5OccupiedFromString(String value) {
        this.slot5Occupied(Boolean.parseBoolean(value));
    }

    @Override
    public int maxOffset() {
        return MAX_OFFSET;
    }

    @Override
    int offsetID() {
        int id = 0;
        id = id * FACING_RADIX + facingToIndex();
        id = id * SLOT0OCCUPIED_RADIX + slot0OccupiedToIndex();
        id = id * SLOT1OCCUPIED_RADIX + slot1OccupiedToIndex();
        id = id * SLOT2OCCUPIED_RADIX + slot2OccupiedToIndex();
        id = id * SLOT3OCCUPIED_RADIX + slot3OccupiedToIndex();
        id = id * SLOT4OCCUPIED_RADIX + slot4OccupiedToIndex();
        id = id * SLOT5OCCUPIED_RADIX + slot5OccupiedToIndex();
        return id;
    }

    @Override
    void loadFromOffset(int id) {
        slot5OccupiedFromIndex(id % SLOT5OCCUPIED_RADIX); id /= SLOT5OCCUPIED_RADIX;
        slot4OccupiedFromIndex(id % SLOT4OCCUPIED_RADIX); id /= SLOT4OCCUPIED_RADIX;
        slot3OccupiedFromIndex(id % SLOT3OCCUPIED_RADIX); id /= SLOT3OCCUPIED_RADIX;
        slot2OccupiedFromIndex(id % SLOT2OCCUPIED_RADIX); id /= SLOT2OCCUPIED_RADIX;
        slot1OccupiedFromIndex(id % SLOT1OCCUPIED_RADIX); id /= SLOT1OCCUPIED_RADIX;
        slot0OccupiedFromIndex(id % SLOT0OCCUPIED_RADIX); id /= SLOT0OCCUPIED_RADIX;
        facingFromIndex(id % FACING_RADIX); id /= FACING_RADIX;
    }

    @Override
    public void load(Map<String, String> properties) {
        if (properties.containsKey("facing")) {
            facingFromString(properties.get("facing"));
        }
        if (properties.containsKey("slot_0_occupied")) {
            slot0OccupiedFromString(properties.get("slot_0_occupied"));
        }
        if (properties.containsKey("slot_1_occupied")) {
            slot1OccupiedFromString(properties.get("slot_1_occupied"));
        }
        if (properties.containsKey("slot_2_occupied")) {
            slot2OccupiedFromString(properties.get("slot_2_occupied"));
        }
        if (properties.containsKey("slot_3_occupied")) {
            slot3OccupiedFromString(properties.get("slot_3_occupied"));
        }
        if (properties.containsKey("slot_4_occupied")) {
            slot4OccupiedFromString(properties.get("slot_4_occupied"));
        }
        if (properties.containsKey("slot_5_occupied")) {
            slot5OccupiedFromString(properties.get("slot_5_occupied"));
        }
    }

    @Override
    public String toString() {
        return "ChiseledBookShelfData[facing=" + String.valueOf(facing).toLowerCase(Locale.ENGLISH) + ";slot_0_occupied=" + String.valueOf(slot0Occupied).toLowerCase(Locale.ENGLISH) + ";slot_1_occupied=" + String.valueOf(slot1Occupied).toLowerCase(Locale.ENGLISH) + ";slot_2_occupied=" + String.valueOf(slot2Occupied).toLowerCase(Locale.ENGLISH) + ";slot_3_occupied=" + String.valueOf(slot3Occupied).toLowerCase(Locale.ENGLISH) + ";slot_4_occupied=" + String.valueOf(slot4Occupied).toLowerCase(Locale.ENGLISH) + ";slot_5_occupied=" + String.valueOf(slot5Occupied).toLowerCase(Locale.ENGLISH) + "]";
    }
}
