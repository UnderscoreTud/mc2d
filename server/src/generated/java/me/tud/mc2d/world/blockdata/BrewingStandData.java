package me.tud.mc2d.world.blockdata;

import java.util.Locale;
import java.util.Map;
import javax.annotation.processing.Generated;
import org.jetbrains.annotations.ApiStatus;

/**
 * This class contains autogenerated code. Please do <b>NOT</b> edit manually.
 */
@Generated("me.tud.mc2d.generators.blockdata.BlockDataGenerator")
public final class BrewingStandData extends BlockData {
    private static final int HAS_BOTTLE0_RADIX = 2;

    private static final int HAS_BOTTLE1_RADIX = 2;

    private static final int HAS_BOTTLE2_RADIX = 2;

    static final int MAX_OFFSET = HAS_BOTTLE0_RADIX * HAS_BOTTLE1_RADIX * HAS_BOTTLE2_RADIX - 1;

    private boolean hasBottle0 = false;

    private boolean hasBottle1 = false;

    private boolean hasBottle2 = false;

    @ApiStatus.Internal
    public BrewingStandData(int startingID) {
        super(startingID);
    }

    public boolean hasBottle0() {
        return this.hasBottle0;
    }

    public void hasBottle0(boolean hasBottle0) {
        this.hasBottle0 = hasBottle0;
    }

    private int hasBottle0ToIndex() {
        return this.hasBottle0 ? 0 : 1;
    }

    private void hasBottle0FromIndex(int index) {
        this.hasBottle0(index == 0);
    }

    private void hasBottle0FromString(String value) {
        this.hasBottle0(Boolean.parseBoolean(value));
    }

    public boolean hasBottle1() {
        return this.hasBottle1;
    }

    public void hasBottle1(boolean hasBottle1) {
        this.hasBottle1 = hasBottle1;
    }

    private int hasBottle1ToIndex() {
        return this.hasBottle1 ? 0 : 1;
    }

    private void hasBottle1FromIndex(int index) {
        this.hasBottle1(index == 0);
    }

    private void hasBottle1FromString(String value) {
        this.hasBottle1(Boolean.parseBoolean(value));
    }

    public boolean hasBottle2() {
        return this.hasBottle2;
    }

    public void hasBottle2(boolean hasBottle2) {
        this.hasBottle2 = hasBottle2;
    }

    private int hasBottle2ToIndex() {
        return this.hasBottle2 ? 0 : 1;
    }

    private void hasBottle2FromIndex(int index) {
        this.hasBottle2(index == 0);
    }

    private void hasBottle2FromString(String value) {
        this.hasBottle2(Boolean.parseBoolean(value));
    }

    @Override
    public int maxOffset() {
        return MAX_OFFSET;
    }

    @Override
    int offsetID() {
        int id = 0;
        id = id * HAS_BOTTLE0_RADIX + hasBottle0ToIndex();
        id = id * HAS_BOTTLE1_RADIX + hasBottle1ToIndex();
        id = id * HAS_BOTTLE2_RADIX + hasBottle2ToIndex();
        return id;
    }

    @Override
    void loadFromOffset(int id) {
        hasBottle2FromIndex(id % HAS_BOTTLE2_RADIX); id /= HAS_BOTTLE2_RADIX;
        hasBottle1FromIndex(id % HAS_BOTTLE1_RADIX); id /= HAS_BOTTLE1_RADIX;
        hasBottle0FromIndex(id % HAS_BOTTLE0_RADIX); id /= HAS_BOTTLE0_RADIX;
    }

    @Override
    public void load(Map<String, String> properties) {
        if (properties.containsKey("has_bottle_0")) {
            hasBottle0FromString(properties.get("has_bottle_0"));
        }
        if (properties.containsKey("has_bottle_1")) {
            hasBottle1FromString(properties.get("has_bottle_1"));
        }
        if (properties.containsKey("has_bottle_2")) {
            hasBottle2FromString(properties.get("has_bottle_2"));
        }
    }

    @Override
    public String toString() {
        return "BrewingStandData[has_bottle_0=" + String.valueOf(hasBottle0).toLowerCase(Locale.ENGLISH) + ";has_bottle_1=" + String.valueOf(hasBottle1).toLowerCase(Locale.ENGLISH) + ";has_bottle_2=" + String.valueOf(hasBottle2).toLowerCase(Locale.ENGLISH) + "]";
    }
}
