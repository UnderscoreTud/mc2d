package me.tud.mc2d.world.blockdata;

import com.google.common.base.Preconditions;
import java.util.Locale;
import java.util.Map;
import javax.annotation.processing.Generated;
import me.tud.mc2d.world.blockdata.properties.HasPowered;
import org.jetbrains.annotations.ApiStatus;
import org.jetbrains.annotations.Range;

/**
 * This class contains autogenerated code. Please do <b>NOT</b> edit manually.
 */
@Generated("me.tud.mc2d.generators.blocks.BlocksGenerator")
public final class NoteData extends BlockData implements HasPowered {
    private static final int INSTRUMENT_RADIX = 23;

    private static final int NOTE_RADIX = 25;

    private static final int POWERED_RADIX = 2;

    static final int MAX_OFFSET = INSTRUMENT_RADIX * NOTE_RADIX * POWERED_RADIX - 1;

    private Instrument instrument = Instrument.HARP;

    private @Range(from = 0, to = 24) int note = 0;

    private boolean powered = false;

    @ApiStatus.Internal
    public NoteData(int startingID) {
        super(startingID);
    }

    public Instrument instrument() {
        return this.instrument;
    }

    public void instrument(Instrument instrument) {
        Preconditions.checkNotNull(instrument, "instrument");
        this.instrument = instrument;
    }

    private int instrumentToIndex() {
        return this.instrument.ordinal();
    }

    private void instrumentFromIndex(int index) {
        this.instrument(Instrument.values()[index]);
    }

    private void instrumentFromString(String value) {
        this.instrument(Instrument.parse(value));
    }

    public @Range(from = 0, to = 24) int note() {
        return this.note;
    }

    public void note(@Range(from = 0, to = 24) int note) {
        Preconditions.checkArgument(0 <= note && note <= 24, "Value must be in [0, 24], got " + note);
        this.note = note;
    }

    private int noteToIndex() {
        return this.note;
    }

    private void noteFromIndex(int index) {
        this.note(index);
    }

    private void noteFromString(String value) {
        this.note(Integer.parseInt(value));
    }

    @Override
    public boolean powered() {
        return this.powered;
    }

    @Override
    public void powered(boolean powered) {
        this.powered = powered;
    }

    private int poweredToIndex() {
        return this.powered ? 0 : 1;
    }

    private void poweredFromIndex(int index) {
        this.powered(index == 0);
    }

    private void poweredFromString(String value) {
        this.powered(Boolean.parseBoolean(value));
    }

    @Override
    public int maxOffset() {
        return MAX_OFFSET;
    }

    @Override
    int offsetID() {
        int id = 0;
        id = id * INSTRUMENT_RADIX + instrumentToIndex();
        id = id * NOTE_RADIX + noteToIndex();
        id = id * POWERED_RADIX + poweredToIndex();
        return id;
    }

    @Override
    void loadFromOffset(int id) {
        poweredFromIndex(id % POWERED_RADIX); id /= POWERED_RADIX;
        noteFromIndex(id % NOTE_RADIX); id /= NOTE_RADIX;
        instrumentFromIndex(id % INSTRUMENT_RADIX); id /= INSTRUMENT_RADIX;
    }

    @Override
    public void load(Map<String, String> properties) {
        if (properties.containsKey("instrument")) {
            instrumentFromString(properties.get("instrument"));
        }
        if (properties.containsKey("note")) {
            noteFromString(properties.get("note"));
        }
        if (properties.containsKey("powered")) {
            poweredFromString(properties.get("powered"));
        }
    }

    @Override
    public String toString() {
        return "NoteData[instrument=" + String.valueOf(instrument).toLowerCase(Locale.ENGLISH) + ";note=" + String.valueOf(note).toLowerCase(Locale.ENGLISH) + ";powered=" + String.valueOf(powered).toLowerCase(Locale.ENGLISH) + "]";
    }

    public enum Instrument {
        HARP,

        BASEDRUM,

        SNARE,

        HAT,

        BASS,

        FLUTE,

        BELL,

        GUITAR,

        CHIME,

        XYLOPHONE,

        IRON_XYLOPHONE,

        COW_BELL,

        DIDGERIDOO,

        BIT,

        BANJO,

        PLING,

        ZOMBIE,

        SKELETON,

        CREEPER,

        DRAGON,

        WITHER_SKELETON,

        PIGLIN,

        CUSTOM_HEAD;

        public static Instrument parse(String value) {
            return switch (value.toLowerCase(Locale.ENGLISH)) {
                case "harp" -> Instrument.HARP;
                case "basedrum" -> Instrument.BASEDRUM;
                case "snare" -> Instrument.SNARE;
                case "hat" -> Instrument.HAT;
                case "bass" -> Instrument.BASS;
                case "flute" -> Instrument.FLUTE;
                case "bell" -> Instrument.BELL;
                case "guitar" -> Instrument.GUITAR;
                case "chime" -> Instrument.CHIME;
                case "xylophone" -> Instrument.XYLOPHONE;
                case "iron_xylophone" -> Instrument.IRON_XYLOPHONE;
                case "cow_bell" -> Instrument.COW_BELL;
                case "didgeridoo" -> Instrument.DIDGERIDOO;
                case "bit" -> Instrument.BIT;
                case "banjo" -> Instrument.BANJO;
                case "pling" -> Instrument.PLING;
                case "zombie" -> Instrument.ZOMBIE;
                case "skeleton" -> Instrument.SKELETON;
                case "creeper" -> Instrument.CREEPER;
                case "dragon" -> Instrument.DRAGON;
                case "wither_skeleton" -> Instrument.WITHER_SKELETON;
                case "piglin" -> Instrument.PIGLIN;
                case "custom_head" -> Instrument.CUSTOM_HEAD;
                default -> throw new IllegalArgumentException();
            };
        }
    }
}
